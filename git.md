# Basic workflow
### What is version control?
A version control system is a tool that manages changes made to the files and directories in a project. Many version control systems exist; this lesson focuses on one called Git, which is used by many of the data science tools covered in our other lessons. Its strengths are:
	• Nothing that is saved to Git is ever lost, so you can always go back to see which results were generated by which versions of your programs.
	• Git automatically notifies you when your work conflicts with someone else's, so it's harder (but not impossible) to accidentally overwrite work.
	• Git can synchronize work done by different people on different machines, so it scales as your team does.
Version control isn't just for software: books, papers, parameter sets, and anything that changes over time or needs to be shared can and should be stored and shared using something like Git

2 parts:
	- Files + directories created & edited directly
	- Metadata about the project's history
	- Combo of these is a repository

All metadata is stored in a directory called .git, located in the root directory of the repository. Git expects this informtion to be laid out in a precise way, so you should 	never edit or delete anything in .git


When you are using Git, you will frequently want to check the status of your repository. To do this, run the command:
 `git status`
 which displays a list of the files that have been modified since the last time changes were saved.


How can I tell what I have changed?
Git has a staging area in which it stores files with changes you want to save that haven't been saved yet. Putting files in the staging area is like putting things in a box, while committing those changes is like putting that box in the mail: you can add more things to the box or take things out as often as you want, but once you put it in the mail, you can't make further changes

`git status` shows you which files are in this staging area, and which files have changes that haven't yet been put there. In order to compare the file as it currently is to what you last saved, you can use git diff filename. git diff without any filenames will show you all the changes in your repository, while git diff directory will show you the changes to the files in some directory.

##### What is in a diff?
A diff is a formatted display of the differences between two sets of files. Git displays diffs like this:
```
diff --git a/report.txt b/report.txt
index e713b17..4c0742a 100644
--- a/report.txt
+++ b/report.txt
@@ -1,4 +1,5 @@
-# Seasonal Dental Surgeries 2017-18
+# Seasonal Dental Surgeries (2017) 2017-18
+# TODO: write new summary
```

This shows:
	• The command used to produce the output (in this case, diff --git). In it, a and b are placeholders meaning "the first version" and "the second version".
	• An index line showing keys into Git's internal database of changes. We will explore these in the next chapter.
	• --- a/report.txt and +++ b/report.txt, wherein lines being removed are prefixed with - and lines being added are prefixed with +.
	• A line starting with @@ that tells where the changes are being made. The pairs of numbers are start line and number of lines (in that section of the file where changes occurred). This diff output indicates changes starting at line 1, with 5 lines where there were once 4.
	• A line-by-line listing of the changes with - showing deletions and + showing additions (we have also configured Git to show deletions in red and additions in green). Lines that haven't changed are sometimes shown before and after the ones that have in order to give context; when they appear, they don't have either + or - in front of them.
Desktop programming tools like RStudio can turn diffs like this into a more readable side-by-side display of changes; you can also use standalone tools like DiffMerge or WinMerge.

To compare the state of your files with those in the staging area, you can use git diff -r HEAD. The -r flag means "compare to a particular revision", and HEAD is a shortcut meaning "the most recent commit".
You can restrict the results to a single file or directory using git diff -r HEAD path/to/file, where the path to the file is relative to where you are (for example, the path from the root directory of the repository).


# Commit Changes
To save the changes in the staging area, you use the command git commit. It always saves everything that is in the staging area as one unit: as you will see later, when you want to undo changes to a project, you undo all of a commit or none of it.
When you commit changes, Git requires you to enter a log message. This serves the same purpose as a comment in a program: it tells the next person to examine the repository why you made a change.
By default, Git launches a text editor to let you write this message. To keep things simple, you can use `-m "some message in quotes"` on the command line to enter a single-line message like this:
`git commit -m "Program appears to have become self-aware."`
- If you accidentally mistype a commit message, you can change it using the `--amend` flag.
`git commit --amend - m "new message"`
The command git log is used to view the log of the project's history. Log entries are shown most recent first, and look like this:
```commit 0430705487381195993bac9c21512ccfb511056d
Author: Rep Loop <repl@datacamp.com>
Date:   Wed Sep 20 13:42:26 2017 +0000
Added year to report title.
```
## View a repo's history
The commit line displays a unique ID for the commit called a hash; we will explore these further in the next chapter. The other lines tell you who made the change, when, and what log message they wrote for the change.
When you run git log, Git automatically uses a pager to show one screen of output at a time. Press the space bar to go down a page or the 'q' key to quit.

You are in the directory dental, which is a Git repository. Use a single Git command to view the repository's history. What is the message on the very first entry in the log (which is displayed last)?
Keep in mind that not all entries may be visible on the first screen, and that you might need to check additional pages to see the very first entry.

# Repositories
### Git repos have a 3 level structure:

1.  A commit contains metadata such as the author, the commit message, and the time the commit happened. In the diagram below, the most recent commit is at the bottom (feed0098), underneath its parent commits.
2.  Each commit also has a tree, which tracks the names and locations in the repository when that commit happened. In the oldest (top) commit, there were two files tracked by the repository.
3.  For each of the files listed in the tree, there is a blob. This contains a compressed snapshot of the contents of the file when the commit happened (blob is short for binary large object, which is a SQL database term for "may contain data of any kind"). In the middle commit, report.md and draft.md were changed, so the blobs are shown next to that commit. data/northern.csv didn't change in that commit, so the tree links to the blob from the previous commit. Reusing blobs between commits help make common operations fast and minimizes storage space.

![[Pasted image 20220421011843.png]]
Every commit to a repository has a unique identifier called a hash (since it is generated by running the changes through a pseudo-random number generator called a hash function). This hash is normally written as a 40-character hexadecimal string like 7c35a3ce607a14953f070f0f83b5d74c2296ef93, but most of the time, you only have to give Git the first 6 or 8 characters in order to identify the commit you mean.

Hashes are what enable Git to share data efficiently between repositories. If two files are the same, their hashes are guaranteed to be the same. Similarly, if two commits contain the same files and have the same ancestors, their hashes will be the same as well. Git can therefore tell what information needs to be saved where by comparing hashes rather than comparing entire files.

To view the details of a specific commit, you use the command git show with the first few characters of the commit's hash. For example, the command:

`git show 0da2f7`

A hash is like an absolute path: it identifies a specific commit. Another way to identify a commit is to use the equivalent of a relative path. The special label HEAD, which we saw in the previous chapter, always refers to the most recent commit. The label HEAD~1 then refers to the commit before it, while HEAD~2 refers to the commit before that, and so on.

Note that the symbol between HEAD and the number is a tilde ~, not a minus sign -, and that there cannot be spaces before or after the tilde.

How can I see who changed what in a file?

git log displays the overall history of a project or file, but Git can give even more information. The command git annotate file shows who made the last change to each line of a file and when. For example, the first three lines of output from git annotate report.txt look something like this:

`04307054        (  Rep Loop     2017-09-20 13:42:26 +0000       1)# Seasonal Dental Surgeries (2017) 2017-18   5e6f92b6        (  Rep Loop     2017-09-20 13:42:26 +0000       2)   5e6f92b6        (  Rep Loop     2017-09-20 13:42:26 +0000       3)TODO: write executive summary.`

Each line contains five elements, with elements two to four enclosed in parentheses. When inspecting the first line, we see:

1.  The first eight digits of the hash, 04307054.
2.  The author, Rep Loop.
3.  The time of the commit, 2017-09-20 13:42:26 +0000.
4.  The line number, 1.
5.  The contents of the line, # Seasonal Dental Surgeries (2017) 2017-18.

### How can I see what changed between two commits?

git show with a commit ID shows the changes made in a particular commit. To see the changes between two commits, you can use git diff ID1..ID2, where ID1 and ID2 identify the two commits you're interested in, and the connector .. is a pair of dots. For example, git diff abc123..def456 shows the differences between the commits abc123 and def456, while git diff HEAD~1..HEAD~3 shows the differences between the state of the repository one commit in the past and its state three commits in the past.

## Remove unwanted files

Git can help you clean up files that you have told it you don't want. The command 
`git clean -n`
will show you a list of files that are in the repository, but whose history Git is not currently tracking.
**be careful with `git clean`**
A similar command git clean -f will then delete those files.

**Use this command carefully**: git clean only works on untracked files, so by definition, their history has not been saved. If you delete them with git clean -f, they're gone for good.

![[Pasted image 20220421011637.png]]
## View git config settings:

Like most complex pieces of software, Git allows you to change its default settings. To see what the settings are, you can use the command git config --list with one of three additional options:

-   --system: settings for every user on this computer.
-   --global: settings for every one of your projects.
-   --local: settings for one specific project.

Each level overrides the one above it, so local settings (per-project) take precedence over global settings (per-user), which in turn take precedence over system settings (for all users on the computer).

Most of Git's settings should be left as they are. However, there are two you should set on every computer you use: your name and your email address. These are recorded in the log every time you commit a change, and are often used to identify the authors of a project's content in order to give credit (or assign blame, depending on the circumstances).

To change a configuration value for all of your projects on a particular computer, run the command:

git config --global setting value

## Commit changes selectively

You don't have to put all of the changes you have made recently into the staging area at once. For example, suppose you are adding a feature to analysis.R and spot a bug in cleanup.R. After you have fixed it, you want to save your work. Since the changes to cleanup.R aren't directly related to the work you're doing in analysis.R, you should save your work in two separate commits.

The syntax for staging a single file is git add path/to/file.

If you make a mistake and accidentally stage a file you shouldn't have, you can unstage the additions with git reset HEAD and try again.

## Undo changes to unstaged files

How can I undo changes to unstaged files?

Suppose you have made changes to a file, then decide you want to undo them. Your text editor may be able to do this, but a more reliable way is to let Git do the work. The command:

git checkout -- filename

will discard the changes that have not yet been staged. (The double dash -- must be there to separate the git checkout command from the names of the file or files you want to recover.)

Use this command carefully: once you discard changes in this way, they are gone forever.

## Undo changes to staged files

At the start of this chapter you saw that git reset will unstage files that you previously staged using git add. By combining git reset with git checkout, you can undo changes to a file that you staged changes to. The syntax is as follows.

git reset HEAD path/to/file  
git checkout -- path/to/file

(You may be wondering why there are two commands for re-setting changes. The answer is that unstaging a file and undoing changes are both special cases of more powerful Git operations that you have not yet seen.)

How do I restore an old version of a file?

You previously saw how to use git checkout to undo the changes that you made since the last commit. This command can also be used to go back even further into a file's history and restore versions of that file from a commit. In this way, you can think of committing as saving your work, and checking out as loading that saved version.

The syntax for restoring an old version takes two arguments: the hash that identifies the version you want to restore, and the name of the file.

For example, if git log shows this:

```
commit ab8883e8a6bfa873d44616a0f356125dbaccd9ea  
Author: Author: Rep Loop <repl@datacamp.com>  
Date:   Thu Oct 19 09:37:48 2017 -0400
```

Adding graph to show latest quarterly results.
```
commit 2242bd761bbeafb9fc82e33aa5dad966adfe5409  
Author: Author: Rep Loop <repl@datacamp.com>  
Date:   Thu Oct 16 09:17:37 2017 -0400
```
Modifying the bibliography format.

then `git checkout 2242bd report.txt` would replace the current version of report.txt with the version that was committed on October 16. Notice that this is the same syntax that you used to undo the unstaged changes, except -- has been replaced by a hash.

Restoring a file doesn't erase any of the repository's history. Instead, the act of restoring the file is saved as another commit, because you might later want to undo your undoing.

One more thing: there's another feature of git log that will come in handy here. Passing - followed by a number restricts the output to that many commits. For example, git log -3 report.txt shows you the last three commits involving report.txt.

# Collaborating
- If you want to create a repository for a new project in the current working directory, you can simply say `git init project-name`
    - where `project-name` is the name you want the new repository's root directory to have.

- One thing you should not do is create one Git repository inside another
  - While Git does allow this, updating nested repositories becomes very complicated very quickly, since you need to tell Git which of the two .git directories the update is to be stored in. 
    - Very large projects occasionally need to do this, but most programmers and data analysts try to avoid getting into this situation.

## CLONE EXISTING REPOSITORY
Sometimes you will join a project that is already running, inherit a project from someone else, or continue working on one of your own projects on a new machine. In each case, you will clone an existing repository instead of creating a new one. Cloning a repository does exactly what the name suggests: it creates a copy of an existing repository (including all of its history) in a new directory.
To clone a repository, use the command `git clone <URL>`, where URL identifies the repository you want to clone. This will normally be something like 
https://github.com/datacamp/project.git
but for this lesson, we will use a repository on the local file system, so you can just use a path to that directory. When you clone a repository, Git uses the name of the existing repository as the name of the clone's root directory, for example:
git clone /existing/project
will create a new directory called project inside your home directory. If you want to call the clone something else, add the directory name you want to the command:
`git clone /existing/project newprojectname`